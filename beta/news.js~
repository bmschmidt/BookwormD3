//There should always be a query variable present: from that, it should be possible to derive anything else we'll ever need, and any changes can update it directly.

var query = {
    "method":"return_json",
    "words_collation":"Case_Sensitive",
    "groups":["paperid","lat","lng"],
    "database":"ChronAm",
    "counttype":["WordCount","TotalWords"],
    "search_limits":{
	"date_year":{"$lte":1922,"$gte":1850},
	"word":["Ohio river"]
    }
};

var queryBox = $('<div />');
$('<input />').attr("id", "word_box").val(query['search_limits']['word'][0]).appendTo(queryBox);
// clear below
//$('<input />').attr("id", "word_box2").val('Mississippi').appendTo(queryBox);
$('<input />').attr("id", "year1_box").val(query['search_limits']['date_year']['$gte']).appendTo(queryBox);
$('<input />').attr("id", "year2_box").val(query['search_limits']['date_year']['$lte']).appendTo(queryBox);
$('<button />').text('Submit').click(function(){runQuery();}).appendTo(queryBox);
$('<span />').attr("id", "max_x").appendTo(queryBox);
queryBox.appendTo($('body'));


$('body').keypress(function(e){
    if(e.which == 13){
        runQuery();
    }
});

var data; // loaded asynchronously

var svg = d3.select("#chart")
    .append("svg")
    .attr("background","black")

// Make the background map

var projection = d3.geo.albersUsa()
    .translate([700,350])
    .scale([1500]);

var path = d3.geo.path()
    .projection(projection);

var states = svg.append("g")
    .attr("id", "states");

d3.json("../data/us-states.json", function(json) {
    states.selectAll("path")
        .data(json.features)
        .enter().append("path")
        .attr("d", path)
        .attr('fill',"grey")
});


// Prepare the paper points.
var paperdiv = svg.append("g").attr("id","paperdiv");

var paperdata = [];

var paperpoints = paperdiv
    .selectAll("circle")
    .data(paperdata,key)

paperpoints
    .enter()
    .append('circle')
    .attr('id',function(d) {return(Math.random()*1000)})
    .attr('cx',function(d) {return(Math.random()*1000)})
    .attr('cy',300)
    .attr('fill','red')
    .attr('r',15)
    .attr('opacity',.2)


// Make the d3 scales

colors = d3.scale.sqrt().range(["rgb(254,249,240)","rgb(246,188,91)","rgb(209,35,11)"])
colors = d3.scale.sqrt().range(["white","yellow","red"])
transparency = d3.scale.sqrt().range([0,1]);
nwords = d3.scale.sqrt().range([3,25]);

function key(d) {return d.key;};

function popitup(url) {
    newwindow=window.open(url,'name','height=640,width=1000');
    if (window.focus) {newwindow.focus()}
    return false;
}

function destinationize(query) {
    return( "http://arxiv.culturomics.org/cgi-bin/dbbindings.py/?queryTerms=" + encodeURIComponent(JSON.stringify(query)))
};

function runQuery() {
    paperdiv.selectAll('circle')
	.transition()
	.duration(2500)
	.attr('r',.1)
	.attr('fill','grey');

    query['search_limits']['word'] = [$("#word_box").val()];
    query['search_limits']['date_year']['$gte'] = parseInt($("#year1_box").val());
    query['search_limits']['date_year']['$lte'] = parseInt($("#year2_box").val());
    
    webpath = destinationize(query);
    console.log(webpath);

    d3.json(webpath,function(json) {
	paperdata = [];
	$.each(json,function(paperid,value) {
	    $.each(value,function(lat,value2) {
		$.each(value2,function(lng,value3) {
		    point = new Object();
		    point.lat = parseFloat(lat);
		    point.lng = parseFloat(lng);
		    point.value = value3[0]/value3[1]*1000000;
		    point.total = value3[1];
		    point.paperid = paperid;
		    point.key = paperid;
		    paperdata.push(point)
		});
	    });
	});
	//zero out the scales
	//colors.domain([0.00001,0.000001,0.000001]);
	//nwords.domain([100000,0]);
	//transparency.domain([100000,0])
	values = paperdata
	console.log(values);
	colors.domain([d3.min(values)+.00001,(Math.sqrt(d3.max(values)/2)^2),d3.max(values)])
	$.each(paperdata, function(index,d){
            if (d.value > colors.domain()[2]) {
		colors.domain([0,1,d.value]);
	    }
	    if (d.total > nwords.domain()[1]) {
		nwords.domain([nwords.domain()[0],d.total])
	    }
	    if (d.total < nwords.domain()[0]) {
		nwords.domain([d.total,nwords.domain()[1]]);
	    }
	});

	transparency.domain(nwords.domain());
//	colors.domain([
//	    0,
//	    (Math.sqrt(colors.domain()[2])/2)^2,
//	    colors.domain()[2]
//	])

	$("#max_x").text(' maximum value: ' + Math.round( 100*colors.domain()[1],2)/100 );
	
//	paperdiv.selectAll('circle').remove()

	paperpoints
	    .data(paperdata,key)
	    .enter()
	  .append('circle')
	    .on('click',function(d) {
		popitup('http://chroniclingAmerica.loc.gov/lccn/' + d.paperid + '/')
	    })

	    .attr('transform',function(d) {
		coords = projection([d.lng,d.lat]);
		return "translate(" + coords[0] +","+ coords[1] + ")"})
	    .attr('id',function(d) {return(d.paperid)})
	    .attr('opacity','.5')
	    .attr('onmouseover', "evt.target.setAttribute('opacity','1');")
	    .attr('onmouseout',  "evt.target.setAttribute('opacity','.5');")
	    .transition()
	    .duration(2500)
	    .attr('r',function(d) {return(nwords(d.total))})
	    .attr('fill',function(d) {return(colors(d.value))})

	paperpoints.sort(function(d) {return(d.value)} );

	paperpoints.exit().remove()

    });
}

runQuery()