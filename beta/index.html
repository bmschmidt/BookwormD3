    <!DOCTYPE html>
    <html>
    <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Geographic Bookworm Panel</title>
    <script type="text/javascript" src="../d3.v2.js"></script>
    <script type="text/javascript" src="searchWindow.js"></script>
    <script type="text/javascript" src="mapchart.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <link type="text/css" rel="stylesheet" href="beta.css"/>
    <link type="text/css" rel="stylesheet" href="../lib/colorbrewer/colorbrewer.css"/>
    </head>
    <body>
    <div id="chart"></div>
    <script type="text/javascript">


//There should always be a query variable present: from that, it should be possible to derive anything else we'll ever need, and any changes can update it directly.

var defaultQuery = {
    "method":"return_json",
    "words_collation":"Case_Sensitive",
    "groups":["state","date_year"],
    "database":"ChronAm",
    "counttype":["WordCount","TotalWords"],
    "search_limits":{
        "date_year":{"$lte":1922,"$gte":1850},
        "word":["Ohio river"]
    }
};

if (window.location.host=="melville.seas.harvard.edu") {
    var defaultQuery = {"method":"return_json","words_collation":"All_Words_with_Same_Stem","groups":["lc1","year"],"database":"presidio","counttype":["WordCount","TotalWords"],"search_limits":{"year":{"$lte":1922,"$gte":1850},"word":["natural selection"]}}
}


if(window.location.hash) {
    var hash = window.location.hash.substring(1);
    decoded = decodeURIComponent(hash)
    var query =  JSON.parse(decoded)
    console.log(query)
} else {
    var query=defaultQuery
}

// And for now I'm just having that query live in a text box. We can use the real Bookworm query entries instead, but no use reinventing that wheel here.
var APIbox = d3.selectAll('div')
    .append('input')
    .attr('type', String) // implicit function(d, i) { return ''+d; }
    .attr('name', 'lone-ranger')
    .attr('value', JSON.stringify(query))
    .attr('style', 'width: 1400px;')
    .on('change', function(d, i) {
        // 'this' is the node itself
        var pa = d3.select(this.parentNode);
        var ranger_value = +this.value; // identical to +d3.select(this).node().value
        var pn = pa.selectAll('p#display-value')
            .enter();
        pn.each(function(d, i) {
            var sel = d3.select(this);
            if (!d)
            {
                sel.append('span')
                    .attr('id', 'display-value');
            }
        });
        // always update the value shown:
        pn = pa.select('span#display-value');
        pn.text(function() {
            return 'value = ' + ranger_value;
        });
    });

APIbox.update = function() {APIbox.attr('value',JSON.stringify(query))}



//These elements are ugly, and my (Ben's) goal is chiefly to make it so that they work but can be shuffled around on the screen.
//But they're also outdated now

var queryBox = $('<div />');
/* deprecated for the pure json approach

   $('<input />').attr("id", "word_box").val(query['search_limits']['word'][0]).appendTo(queryBox);
   // clear below
   $('<input />').attr("id", "word_box2").val('').appendTo(queryBox);
   $('<input />').attr("id", "year1_box").val(query['search_limits']['date_year']['$gte']).appendTo(queryBox);
   $('<input />').attr("id", "year2_box").val(query['search_limits']['date_year']['$lte']).appendTo(queryBox);
   $('<input />').attr("id", "group1_box").val(query['groups'][0]).appendTo(queryBox);
   $('<input />').attr("id", "group2_box").val(query['groups'][1]).appendTo(queryBox);
   $('<input />').attr("id", "database_box").val(query['database']).appendTo(queryBox);

*/

$('<button />').text('Map Query').click(function(){mapQuery();}).appendTo(queryBox);
$('<button />').text('Heatgrid chart').click(function(){heatMap();}).appendTo(queryBox);
$('<button />').text('Change over Time').click(function(){heatMap();}).appendTo(queryBox);

var options = $('<div />');


queryBox.appendTo($('body'));

$('body').keypress(function(e){
    if(e.which == 13){
        mapQuery();
    }
});

var svg = d3.select("#chart")
    .append("svg")
    .attr("background","cream")

// Make the background map

var projection

//var path = d3.geo.path()
//  .projection(projection);

//These are the things to delete when a new chart is refreshed.

var maplevel = svg.append("g").attr("id", "#maplevel")
var paperdiv = svg.append("g").attr("id","#paperdiv");
var yaxis = svg.append("g").attr("id","#yaxis");
var xaxis = svg.append("g").attr("id","#xaxis");
var legend = svg.append('g').attr('id','#legend');
var title = svg.append('g').attr('id','#title')

var stateItems

drawStates = function() {
    projection = d3.geo.albersUsa()
        .translate([700,350])
        .scale([1500]);

    d3.json("../data/us-states.json", function(json) {
        stateItems = maplevel.selectAll("path")
            .data(json.features)

        stateItems
            .enter()
            .append("path")
            .attr("d", function(d) {
                return(d3.geo.path().projection(projection))
            })
            .attr('fill',"grey")
    });

    if (false) {
        projection = d3.geo.albers()
            .translate([700,350])
            .origin([15,45])
            .scale([150]);


        d3.json("../data/world-countries.json", function(json) {
            stateItems = maplevel.selectAll("path")
                .data(json.features)

            stateItems
                .enter()
                .append("path")
                .attr("d", path)
                .attr('fill',"grey")
        });
    }
}

drawStates = function() {
    projection = d3.geo.albersUsa()
    //        .origin([15,50])
        .translate([700,350])
        .scale([1500])

    ;

    path = d3.geo.path()
        .projection(projection);

    //    states = svg.append("g")
    //      .attr("id", "states")

    stateItems

    d3.json("../data/us-states.json", function(json) {
        stateItems = maplevel.selectAll("path")
            .data(json.features)

        stateItems
            .enter()
            .append("path")
            .attr("d", path)
            .attr('fill',"grey")
    });
}

removeElements = function() {
    vals = ['rect','text','path','circle'].map(function(type) {svg.selectAll(type).transition().remove()})
}

// Prepare the paper points.

var paperdata = [];

var paperpoints = paperdiv
    .selectAll("circle")
    .data(paperdata,function(d) {d.key})

// Make the d3 scales

colors = d3.scale.sqrt().range(["rgb(254,249,240)","rgb(246,188,91)","rgb(209,35,11)"])
//colors = d3.scale.log().range(['rgb(37,52,148)','rgb(44,127,184)','rgb(65,182,196)','rgb(161,218,180)','rgb(255,255,204)'])
colors = d3.scale.log().range(['white','lightblue','red'])



//logcolors = d3.scale.log().range(['green','white','red']);
// PuOr pallette from colorBrewer2.org designed to be color-blind compatible

logcolors = d3.scale.log().range(['rgb(84,39,136)','rgb(153,142,195)','rgb(216,218,235)','rgb(247,247,247)','rgb(254,224,182)',//'rgb(241,163,64)',
                                  'rgb(230,97,1)'])
nwords = d3.scale.sqrt().range([3,25]);

var sizescale = nwords
var colorscale = colors;

function key(d) {return d.key;};

function popitup(url) {
    newwindow=window.open(url,'name','height=640,width=1000');
    if (window.focus) {newwindow.focus()}
    return false;
}

function destinationize(query) {
    return( "/cgi-bin/dbbindings.py/?queryTerms=" + encodeURIComponent(JSON.stringify(query)))
};

function parseBookwormData(json,query) {
    // Just changes the shape around--more complicated than it necessarily should be, but whatever.
    names = [].concat(query.groups).concat(query.counttype);
    function flatten(hash,prepend) {
        results = Object.keys(hash).map(function(key) {
            newpend = prepend.concat(key)
            if (hash[key] instanceof Array)
            {
                return(newpend.concat(hash[key]))
            }
            else {
                vals = flatten(hash[key],newpend)
                return(
                    vals.map(function(array) {
                        return(array)
                    })
                )
            }
        })

        if (results[0][0] instanceof Array) {
            return(results.reduce(function(a,b){return(a.concat(b))}))
        } else {
            return(results)
        }
    }
    function toObject(names, values) {
        var result = {};
        for (var i = 0; i < names.length; i++) {
            result[names[i]] = values[i];}
        return result;
    };
    flat = flatten(json,[]);
    results = flat.map(function(localdata){
        return(toObject(names,localdata));
    })
    return(results)
}



function changeWord() {
    // The idea here is that we can have a dynamic title option that prompts you for new values when you click on it.
    //It's not working quite yet, and maybe it shouldn't
    $('#word_box').val(prompt("Enter new word","Ohio River"))

    mapQuery()

    textdata = [{"id":"title","label":words[0],'x':550,'y':50,'fill':'white'}];
    textLegend =
        title.selectAll('text')
        .data(textdata);

    textLegend.enter()
        .append('text')
        .attr('fill','white')
        .attr('x',function(d) {return(d.x)})
        .attr('y',function(d) {return(d.y)})
        .attr("font-family", "sans-serif")
        .attr("font-size", "70px")
        .text(function(d) {return(d.label)})
    words = query['search_limits']['word']

    textLegend.exit().remove()
}


function comparisontype() {
    //Maybe this function should also match up constraints between the two?
    //There are some differences in the legends and the titles depending if we're comparing to all
    //books or to certain ones. This should be useful for that.
    if ('compare_limits' in query) {
	//This should just test length, not for this particular key as it does. 
        if ('word' in query['compare_limits']) {
            return('comparison');
        }
    } else {return("absolute")}
}

function updateQuery() {
    //make sure the box and the internal state are aligned
    APIbox.update()
    //assign comparison limits if necessary
    comparetype = comparisontype()
    query = JSON.parse(APIbox[0][0].value)
}


topn = function(n,key,paperdata) {
    vals = d3.nest().key(function(d) {return(d[key]);}).entries(paperdata)

    perm = vals.map(function(val) {
        val.total = d3.sum(val.values,function(d) {return(d.TotalWords)})
        return(val)
    })

    perm.sort(function(a,b) {return(b.total-a.total)})
    terms = perm.map(function(a) {return(a.key)})
    return(


        terms.slice(0,n)
    )
}


function heatMap() {

    xlim = [100,900]
    ylim=[75,690]

    updateQuery()
    webpath = destinationize(query);
    console.log(webpath);

    //make the graphic
    group1 = query['groups'][0]
    group2 = query['groups'][1]

    if (query.plotType != heatMap) {
        query.plotType = 'heatMap'
        svg.selectAll('circle').remove()
        svg.selectAll('path').remove()
        svg.selectAll('text').remove()
    }

    d3.json(webpath,function(json) {
        paperdata = parseBookwormData(json,query);

        if (comparisontype()=='comparison') {
            // This probably isn't the best place to do this: what is?
            paperdata = paperdata.map(function(d) {d.CompareWords = d.TotalWords; d.TotalWords = d.WordCount+d.TotalWords;return(d)})
        }

        values = paperdata.map(function(d) {return(d.WordCount/d.TotalWords)});
        totals = paperdata.map(function(d) {return(d.TotalWords)});
        numbers = d3.extent(values)

        numbers[0] = d3.max([(1/10)/1000000,d3.min(values)])

        if (comparisontype()=='comparison') {
            outerbound = d3.min([100,d3.max([1/d3.min(values),d3.max(values)])])
            numbers = [1/outerbound,outerbound]
	    colorscale = logcolors
        }

        min = Math.log(numbers[0])
        max = Math.log(numbers[1])

        colorscale.domain(d3.range(
            min,
            max,
            (max-min)/colorscale.range().length).map(function(n) {return(Math.exp(n))}))
        colorscale.nice()

        nwords.domain(d3.extent(totals))
        nwords.nice()

        years = d3.nest().key(function(d) {return(d[query['groups'][1]]);}).entries(paperdata).map(function(d) {return(d.key)})
        xnames = d3.nest().key(function(d) {return(d[query['groups'][0]]);}).entries(paperdata).map(function(d) {return(d.key)})

        //filter out elements of the array
        xnames = topn(50,query['groups'][0],paperdata)
        paperdata = paperdata.filter(function(entry) {
            return(xnames.indexOf(entry[group1]) > -1)
        })

        //set up scales.
        years.sort()
        xnames.sort()

        x = d3.scale.ordinal().domain(years).rangeBands(xlim);
        y = d3.scale.ordinal().domain(xnames).rangeBands(ylim);

        //set up axes
        ylegendData = xnames.map(function(d) {return({"label":d,"y":y(d)+y.rangeBand()*.9,"x":xlim[1]})})
        ypoints = yaxis.selectAll('text').data(ylegendData,function(d) {return(d.label)})
        ypoints
            .enter()
            .append('text')
            .attr('fill','white')
            .attr('x',function(d) {return(d.x)})
            .attr('y',function(d) {return(d.y)})
            .attr("font-family", "sans-serif")
            .attr("font-size", "13px")
            .text(function(d) {return(d.label)})

        xlegendData = years.map(function(d) {
            objectb = {"year":d,"y":ylim[0]-5,"x":x(d) - 13};
            if (objectb.year != Math.round(objectb.year/5)*5) {objectb.year=""};
            return(objectb);
        })

        xpoints = xaxis
            .selectAll('text')
            .data(xlegendData,function(d) {return(d[group2])})

        xpoints
            .enter()
            .append('text')
            .attr('fill','white')
            .attr('x',function(d) {return(d.x)})
            .attr('y',function(d) {return(d.y)})
            .attr("font-family", "sans-serif")
            .attr("font-size", "13px")
            .attr("fill", "white")
            .text(function(d) {return(d.year)})

        //stupid, but don't want to change the underlying function.

        paperdata.sort(function(d) {return(d.value)} );

        paperdiv.selectAll('rect').remove()
        var mystates = paperdiv.selectAll('rect')
            .data(paperdata,function(d) {return(d.state)})

        mystates
            .enter().append('rect')
            .on('click',function(d) {
                console.log(d)
                searchTemplate = JSON.parse(JSON.stringify(query))
                searchTemplate['search_limits'][group2] = [d[group2]]
                searchTemplate['search_limits'][group1] = [d[group1]]
                //popitup('/ChronAm/#?' + encodeURIComponent(JSON.stringify(searchTemplate)))
                searchWindow(searchTemplate)
            })
            .attr('opacity','.99')
            .attr('onmouseover', "evt.target.setAttribute('opacity','1');")
            .attr('onmouseout',  "evt.target.setAttribute('opacity','.95');")
            .attr('x',function(d) {return(x(d[query['groups'][1]]))})
            .attr('y',function(d) {return(y(d[query['groups'][0]]))})
            .transition()
            .duration(2500)
            .attr('fill',function(d) {
                if (comparisontype()=='comparison') {
                    return(colorscale(d.WordCount/d.CompareWords))}
                else {return(colorscale(d.WordCount/d.TotalWords))}
            })

            .attr('height', y.rangeBand())
            .attr('width', x.rangeBand())

        mystates.exit().transition(1000).remove()
        makeLegend();
    })
}

prettyName = function(number) {
    if (comparisontype()=='absolute') {
        suffix = ''
        switch(number) {
        case number>1000000000:
            number = number/1000000000
            suffix = 'B'
        case number>1000000:
            number = number/1000000
            suffix = 'M'
        case number>1000:
            number = number/1000
            suffix = 'K'
        }
        return(Math.round(number*10)/10+suffix)
    }
    if (comparisontype()=='comparison') {
        if (number >= 1) {return(Math.round(number)) + ":1"}
        if (number < 1) {return("1:" + Math.round(1/number))}
    }
}

var legendPoints = legend.append('g').attr('id','legendPoints')
var ylab = legend.append('g').attr('id','ylab');
var xlab = legend.append('g').attr('id','xlab');
var title = legend.append('g').attr('id','title');
var legendData = [];
var colorLegend = legend.append('g').attr('id','colorLegend');
var sizeLegend = legend.append('g').attr('id','sizeLegend');

function makeLegend() {

    colorLegend.yrange = [75,500]

    colorticks = colorscale.ticks();

    colorLegend.boxheight = (colorLegend.yrange[1]-colorLegend.yrange[0])/colorticks.length +1.5
    colorLegend.width = 25
    colorLegend.xpos  = 10
    colorLegend.plot = true
    colorLegend.title = "Per Million Words"
    colorLegend.colorpoints = colorLegend.selectAll('rect')
    colorLegend.colorlabels   = colorLegend.selectAll('text')

    colorLegend.scale = d3.scale.linear().range(colorLegend.yrange).domain(d3.extent(d3.range(colorticks.length)))

    colorLegend.update = function() {
        colorLegend.data = d3.range(colorticks.length).map(function(n) {
            value =
                {"label":prettyName(colorticks[n]*1000000),
                 "color":colorscale(colorticks[n]),
                 'y':colorLegend.scale(n)
                }
            if (comparisontype()=='comparison') {
                value.label = prettyName(colorticks[n])
            }
            return(value)
        })

        colorLegend.colorpoints.remove()
        colorLegend.colorpoints = colorLegend.selectAll('rect').data(colorLegend.data,function(d) {return(d.y)})
        colorLegend.colorpoints.enter().append('rect')
            .attr('y',function(d) {return(d.y)})
            .attr('height',colorLegend.boxheight)
            .attr('x',colorLegend.xpos)
            .attr('width',colorLegend.width)
            .attr('fill',function(d) {return(d.color)})

        colorLegend.colorlabels
            .remove()

        colorLegend.colorlabels = colorLegend.selectAll('text').data(colorLegend.data,function(d) {return(d.y)})

        colorLegend.colorlabels.enter().append('text')
            .attr('y',function(d) {return(d.y+colorLegend.boxheight*.9)})
            .attr('x',colorLegend.xpos + colorLegend.width *1.5)
            .attr('fill','white')
            .text(function(d) {return(d.label)})

        text1 = "Usage of '" + query['search_limits']['word'][0] + "'"; text2 =  "per Million Words"
        text1 = "Usage of '" + query['search_limits']['word'][0] + "'" +   " per Million Words";text2 = ''
        if (comparisontype()=='comparison') {text1 = "Usage of '" + query['search_limits']['word'][0] + "'"; text2 =  " per use of " + query['compare_limits']['word'][0]}
        colorLegend.append('text').attr('x',colorLegend.xpos+75).attr('y',colorLegend.yrange[0]-25).text(text1).attr('fill','white').attr('font-size',35).attr('font-family',"Arial")
        colorLegend.append('text').attr('x',colorLegend.xpos).attr('y',colorLegend.yrange[0]-5).text(text2).attr('fill','white')
    }

    thisLegend = sizeLegend

    thisLegend.sourceScale = sizescale
    myticks = thisLegend.sourceScale.ticks(5);
    thisLegend.yrange = [300,500]
    thisLegend.boxheight = (thisLegend.yrange[1]-thisLegend.yrange[0])/myticks.length +1.5
    thisLegend.width = 25
    thisLegend.xpos  = 1500-100
    thisLegend.plot = true
    thisLegend.title = "Total size of corpus"
    thisLegend.points = thisLegend.selectAll('circle')
    thisLegend.labels   = thisLegend.selectAll('text')

    thisLegend.scale = d3.scale.linear()
        .range(thisLegend.yrange)
        .domain(d3.extent(d3.range(myticks.length)))

    console.log(myticks);

    thisLegend.update = function() {
        thisLegend.data = d3.range(myticks.length).map(function(n) {
            console.log(myticks[n])
            value =
                {"label":prettyName(myticks[n]),
                 "scaled":thisLegend.sourceScale(myticks[n]),
                 'y':thisLegend.scale(n),
                }
            return(value)
        })

        thisLegend.points.remove()
        thisLegend.points = thisLegend.selectAll('circle').data(thisLegend.data,function(d) {return(d.y)})
        thisLegend.points.enter()
            .append('circle')
            .attr('y',function(d) {return(d.y)})
            .attr('cy',function(d) {return(d.y)})
        //            .attr('height',thisLegend.boxheight)
            .attr('x',thisLegend.xpos)
            .attr('cx',thisLegend.xpos)
        //            .attr('width',thisLegend.width)
        //            .attr('fill',function(d) {return(d.color)})
            .attr('fill','white')
            .attr('r',function(d) {return(d.scaled)})

        thisLegend.labels
            .remove()
        thisLegend.labels = thisLegend.selectAll('text').data(thisLegend.data,function(d) {return(d.y)})
        thisLegend.labels.enter().append('text')
            .attr('y',function(d) {return(d.y)})//+thisLegend.boxheight/2)})
            .attr('x',thisLegend.xpos + thisLegend.width *1.5)
            .attr('fill','white')
            .text(function(d) {return(d.label)})
        text1 = "Total words in corpus"
        text2 = "";
        if (comparisontype()=='comparison') {text1="Uses of both words"}
        thisLegend.append('text').attr('x',thisLegend.xpos).attr('y',thisLegend.yrange[0]-25).text(text1).attr('fill','white')
        thisLegend.append('text').attr('x',thisLegend.xpos).attr('y',thisLegend.yrange[0]-5).text(text2).attr('fill','white')
    }
    thisLegend = colorLegend
    thisLegend.update()
    thisLegend = sizeLegend
    thisLegend.update()
}

//Goofy d3 stuff:
function click(d) {
    var centroid = path.centroid(d),
    translate = projection.translate();
    projection.translate([
        translate[0] - centroid[0] + width / 2,
        translate[1] - centroid[1] + height / 2
    ]);
    zoom.translate(projection.translate());
    states.selectAll("path").transition()
        .duration(1000)
        .attr("d", path);
}


//drawStates()
heatMap()


</script>
    </body>
    </html>



